<script type="module">
import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160/build/three.module.js";
import { PointerLockControls } from "https://cdn.jsdelivr.net/npm/three@0.160/examples/jsm/controls/PointerLockControls.js";

/* ---------------- SETUP ---------------- */

let scene = new THREE.Scene();
scene.fog = new THREE.Fog(0x000000,10,60);

let camera = new THREE.PerspectiveCamera(75,innerWidth/innerHeight,0.2,1000);
let renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth,innerHeight);
renderer.shadowMap.enabled = true;
document.body.appendChild(renderer.domElement);

window.addEventListener("resize",()=>{
    camera.aspect = innerWidth/innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth,innerHeight);
});

let controls = new PointerLockControls(camera,document.body);
scene.add(controls.getObject());
document.body.addEventListener("click",()=>controls.lock());

let clock = new THREE.Clock();

/* ---------------- HUD ---------------- */

let hud = document.createElement("div");
hud.style.position="absolute";
hud.style.top="10px";
hud.style.left="10px";
hud.style.color="white";
hud.style.fontFamily="monospace";
hud.style.fontSize="18px";
hud.innerHTML="Keys: 0 / 3";
document.body.appendChild(hud);

/* ---------------- GAME STATE ---------------- */

let gameState="playing";
let totalKeys=3;
let keysCollected=0;
let doorUnlocked=false;

/* ---------------- PLAYER ---------------- */

let moveForward=false,moveBackward=false,moveLeft=false,moveRight=false;
let playerSpeed=6;
let playerRadius=0.8;

document.addEventListener("keydown",(e)=>{
    if(e.code==="KeyW") moveForward=true;
    if(e.code==="KeyS") moveBackward=true;
    if(e.code==="KeyA") moveLeft=true;
    if(e.code==="KeyD") moveRight=true;
});
document.addEventListener("keyup",(e)=>{
    if(e.code==="KeyW") moveForward=false;
    if(e.code==="KeyS") moveBackward=false;
    if(e.code==="KeyA") moveLeft=false;
    if(e.code==="KeyD") moveRight=false;
});

/* ---------------- LIGHT ---------------- */

scene.add(new THREE.AmbientLight(0x222222,0.3));

let flashlight=new THREE.SpotLight(0xffffff,3,40,Math.PI/8,0.5);
flashlight.castShadow=true;
camera.add(flashlight);
camera.add(flashlight.target);
flashlight.target.position.set(0,0,-1);

/* ---------------- FLOOR ---------------- */

let floor=new THREE.Mesh(
    new THREE.PlaneGeometry(60,60),
    new THREE.MeshPhongMaterial({color:0x111111})
);
floor.rotation.x=-Math.PI/2;
floor.receiveShadow=true;
scene.add(floor);

/* ---------------- COLLISION ---------------- */

let colliders=[];

function addCollider(mesh){
    scene.add(mesh);
    colliders.push(mesh);
}

function updateBoxes(){
    for(let obj of colliders){
        obj.userData.box=new THREE.Box3().setFromObject(obj);
    }
}

function canMove(newPos,radius){
    let box=new THREE.Box3(
        new THREE.Vector3(newPos.x-radius,0,newPos.z-radius),
        new THREE.Vector3(newPos.x+radius,6,newPos.z+radius)
    );
    for(let obj of colliders){
        if(obj.userData.box && obj.userData.box.intersectsBox(box)) return false;
    }
    return true;
}

/* ---------------- WALLS ---------------- */

function wall(x,z,w,h,d){
    let m=new THREE.Mesh(
        new THREE.BoxGeometry(w,h,d),
        new THREE.MeshPhongMaterial({color:0x333333})
    );
    m.position.set(x,h/2,z);
    addCollider(m);
}

wall(0,-30,60,6,1);
wall(0,30,60,6,1);
wall(-30,0,1,6,60);
wall(30,0,1,6,60);

/* ---------------- DOOR ---------------- */

let door=new THREE.Mesh(
    new THREE.BoxGeometry(4,6,1),
    new THREE.MeshPhongMaterial({color:0xff0000})
);
door.position.set(0,3,-29);
addCollider(door);

/* ---------------- KEYS ---------------- */

let keyObjects=[];

function spawnKeys(){
    for(let i=0;i<totalKeys;i++){
        let key=new THREE.Mesh(
            new THREE.BoxGeometry(1,1,1),
            new THREE.MeshPhongMaterial({color:0xffff00})
        );

        let placed=false;
        let attempts=0;

        while(!placed && attempts<100){
            attempts++;
            let x=Math.random()*50-25;
            let z=Math.random()*50-25;

            if(Math.abs(z+29)<5) continue;

            let pos=new THREE.Vector3(x,1,z);
            if(canMove(pos,1)){
                key.position.copy(pos);
                placed=true;
            }
        }

        if(!placed) key.position.set(5,1,5);

        scene.add(key);
        keyObjects.push(key);
    }
}
spawnKeys();

/* ---------------- MONSTER ---------------- */

let monster=new THREE.Group();
scene.add(monster);

let monsterSpeed=4;
let patrolSpeed=2.5;
let monsterRadius=1.5;

let patrolTarget=new THREE.Vector3();
let hasPatrolTarget=false;

let lastKnownPlayerPos=null;
let searchTimer=0;
let maxSearchTime=5;

let body=new THREE.Mesh(
    new THREE.CylinderGeometry(1.2,1.8,8,8),
    new THREE.MeshPhongMaterial({color:0x0a0a0a})
);
body.position.y=4;
monster.add(body);

monster.position.set(10,0,10);

function choosePatrol(){
    let attempts=0;
    while(attempts<30){
        attempts++;
        let x=Math.random()*56-28;
        let z=Math.random()*56-28;
        let pos=new THREE.Vector3(x,0,z);
        if(canMove(pos,monsterRadius)){
            patrolTarget.copy(pos);
            hasPatrolTarget=true;
            return;
        }
    }
    hasPatrolTarget=false;
}

function hasLineOfSight(target){
    let origin=monster.position.clone().add(new THREE.Vector3(0,4,0));
    let direction=target.clone().sub(origin).normalize();
    let raycaster=new THREE.Raycaster(origin,direction);
    let intersects=raycaster.intersectObjects(colliders);
    if(intersects.length===0) return true;
    return intersects[0].distance > origin.distanceTo(target);
}

function moveWithSlide(direction,speed){
    let move=direction.clone().multiplyScalar(speed);
    let newPos=monster.position.clone().add(move);

    if(canMove(newPos,monsterRadius)){
        monster.position.copy(newPos);
        return;
    }

    let slideX=monster.position.clone().add(new THREE.Vector3(move.x,0,0));
    if(canMove(slideX,monsterRadius)){
        monster.position.copy(slideX);
        return;
    }

    let slideZ=monster.position.clone().add(new THREE.Vector3(0,0,move.z));
    if(canMove(slideZ,monsterRadius)){
        monster.position.copy(slideZ);
        return;
    }
}

/* ---------------- LOOP ---------------- */

function animate(){
    if(gameState!=="playing") return;
    requestAnimationFrame(animate);

    let delta=clock.getDelta();
    updateBoxes();

    let playerPos=controls.getObject().position;

    /* PLAYER MOVE */
    let dir=new THREE.Vector3();
    if(moveForward) dir.z-=1;
    if(moveBackward) dir.z+=1;
    if(moveLeft) dir.x-=1;
    if(moveRight) dir.x+=1;

    if(dir.length()>0){
        dir.normalize();
        dir.applyQuaternion(camera.quaternion);
        dir.y=0;
        dir.normalize();
        let move=dir.multiplyScalar(playerSpeed*delta);
        let newPos=playerPos.clone().add(move);
        if(canMove(newPos,playerRadius)){
            controls.getObject().position.copy(newPos);
        }
    }

    /* KEY PICKUP */
    keyObjects=keyObjects.filter(key=>{
        if(key.position.distanceTo(playerPos)<2){
            scene.remove(key);
            keysCollected++;
            hud.innerHTML=`Keys: ${keysCollected} / ${totalKeys}`;
            if(keysCollected>=totalKeys){
                doorUnlocked=true;
                scene.remove(door);
                colliders=colliders.filter(obj=>obj!==door);
            }
            return false;
        }
        return true;
    });

    /* WIN */
    if(doorUnlocked && playerPos.z<-28 && Math.abs(playerPos.x)<2){
        hud.innerHTML="YOU ESCAPED!";
        gameState="win";
        return;
    }

    /* MONSTER AI */
    let dist=monster.position.distanceTo(playerPos);
    let canSeePlayer = dist < 20 && hasLineOfSight(playerPos);

    if(canSeePlayer){
        lastKnownPlayerPos = playerPos.clone();
        searchTimer = 0;
    }

    if(lastKnownPlayerPos){
        let target = lastKnownPlayerPos.clone();
        let mdir = target.sub(monster.position);
        mdir.y=0;

        if(mdir.length()<1){
            searchTimer += delta;
            if(searchTimer > maxSearchTime){
                lastKnownPlayerPos = null;
            }
        }else{
            mdir.normalize();
            moveWithSlide(mdir,monsterSpeed*delta);
        }
    }else{
        if(!hasPatrolTarget) choosePatrol();
        if(hasPatrolTarget){
            let mdir = patrolTarget.clone().sub(monster.position);
            mdir.y=0;
            if(mdir.length()<1){
                hasPatrolTarget=false;
            }else{
                mdir.normalize();
                moveWithSlide(mdir,patrolSpeed*delta);
            }
        }
    }

    /* DEATH */
    if(dist<2){
        hud.innerHTML="YOU DIED.";
        gameState="dead";
        return;
    }

    renderer.render(scene,camera);
}

animate();
</script>
